---
description:
globs:
alwaysApply: true
---
# Rust Best Practices for gold_digger

## Project Structure

- The main entry point is [`main.rs`](mdc:src/main.rs), which delegates core logic to library code in [`lib.rs`](mdc:src/lib.rs).
- Modules for output formats are organized as separate files: [`csv.rs`](mdc:src/csv.rs), [`json.rs`](mdc:src/json.rs), and [`tab.rs`](mdc:src/tab.rs).
- Shared logic and public APIs are exposed via [`lib.rs`](mdc:src/lib.rs).

## Module Organization

- Each output format (CSV, JSON, Tab) should have its own module with a `write` function that takes rows and an output writer.
- Follow the established pattern: `csv.rs`, `json.rs`, `tab.rs` with consistent `write<W: Write>(rows: impl IntoIterator<Item = impl IntoIterator<Item = impl AsRef<str>>>, output: &mut W) -> anyhow::Result<()>` interface.
- Import `std::io::Write` in all output format modules to enable generic writer support.
- Implementations should accept a mutable reference to any writer type (`&mut W where W: Write`) to support files, stdout, memory buffers, etc. without forcing moves.
- Use iterable parameters for rows to accept slices, iterators, or owned Vecs without unnecessary cloning.
- Callers should wrap file handles with `std::io::BufWriter` when passing to module write functions to reduce small-write overhead and improve performance.
- CLI module [`cli.rs`](mdc:src/cli.rs) contains Clap-based CLI definitions and configuration.
- Public functions in modules should be documented with doc comments (`///`).
- Use `pub mod` in [`lib.rs`](mdc:src/lib.rs) to expose modules.

## üö® Critical Safety Rules

### Database Value Conversion (PANIC RISK)

```rust
// ‚ùå NEVER - causes panics on NULL/non-string types
from_value::<String>(row[column.name_str().as_ref()])

// ‚úÖ ALWAYS - safe NULL handling
match &row[column.name_str().as_ref()] {
    mysql::Value::NULL => "".to_string(),
    val => from_value_opt::<String>(val)
        .unwrap_or_else(|_| format!("{:?}", val))
}
```

### Security (NEVER VIOLATE)

- **NEVER** log `DATABASE_URL` or credentials - always redact
- **NEVER** make external service calls at runtime (offline-first)
- Always recommend SQL `CAST(column AS CHAR)` for type safety

## Configuration Architecture

### CLI-First Resolution Pattern

```rust
fn resolve_config_value(cli: &Cli) -> anyhow::Result<String> {
    if let Some(value) = &cli.field {
        Ok(value.clone())                    // CLI flag (highest priority)
    } else if let Ok(value) = env::var("ENV_VAR") {
        Ok(value)                           // Environment variable (fallback)
    } else {
        anyhow::bail!("Missing required configuration")  // Error if neither
    }
}
```

### Configuration Precedence

1. CLI flags (highest priority)
2. Environment variables (fallback)
3. Error if neither provided

## Error Handling Patterns

- Use `anyhow::Result<T>` for application binaries and `thiserror` (or library-specific error types) for library crates
- Handle nullable database values via `Option<T>` or explicit null checks/conversions rather than using unchecked database driver conversions
- Implement credential redaction in all log output
- Use `?` operator for error propagation
- Use `get_required_env()` helper for environment variable validation with contextual error messages
- Avoid panics in production code; prefer returning errors. Only use `panic!` for unrecoverable, truly exceptional cases
- Library crates must return Result-based errors instead of panicking (including in tests) to avoid surprising consumers

## Project File Organization

### Configuration Files

- **Cargo.toml**: Dependencies, features, release profile
- **rustfmt.toml**: Code formatting rules (100-char limit)
- **deny.toml**: Security and license compliance
- **rust-toolchain.toml**: Rust version specification

### Development Automation

- **justfile**: Cross-platform build automation and common tasks
- **.pre-commit-config.yaml**: Git hook configuration for quality gates
- **CHANGELOG.md**: Auto-generated version history (conventional commits)

### Documentation Standards

Required for all public functions using `///`:

```rust
/// Converts MySQL rows to string vectors for output formatting.
///
/// # Arguments
/// * `rows` - Vector of MySQL rows from query execution
///
/// # Returns
/// * `Vec<Vec<String>>` - Converted string data ready for format modules
///
/// # Example
/// ```
/// let string_rows = rows_to_strings(mysql_rows)?;
/// csv::write(string_rows, output)?;
/// ```
pub fn rows_to_strings(rows: Vec<mysql::Row>) -> anyhow::Result<Vec<Vec<String>>> {
    // Implementation
}
```

### Code Style

- Follow [Rustfmt](mdc:https://github.com/rust-lang/rustfmt) conventions for formatting
- Use `snake_case` for function and variable names, `CamelCase` for types and structs
- Prefer iterators and combinators over manual loops where possible
- Use explicit types for function signatures, especially for public APIs
- Prefer grouping imports by standard library, external crates, and local modules, separated by newlines (advisory rule to prevent format-only diffs during reviews)

## Features and Conditional Compilation

- Use Cargo features (see `[features]` in [`Cargo.toml`](mdc:Cargo.toml)) to enable/disable output formats and verbose logging.
- Use `#[cfg(feature = "...")]` to conditionally compile code based on enabled features, as in [`main.rs`](mdc:src/main.rs).

## Dependency Management

- Pin dependency versions in [`Cargo.toml`](mdc:Cargo.toml) and use minimal required features for each crate.
- Use optional dependencies and features for extensibility (e.g., SSL, additional MySQL types).

## Testing and Safety

- Add tests in a `tests/` directory or as `#[cfg(test)]` modules within each file.
- Validate all external input (e.g., environment variables) and handle missing/invalid values gracefully.
- Use the `get_required_env()` helper function for environment variable validation with contextual error messages.
- Prefer returning early on error conditions.

### Test Coverage Guidelines

- **Default Target:** ‚â•80% coverage with `cargo tarpaulin`
- **Recommended Exclusions:** `main.rs`, binary crates, auto-generated code, error enums, and integration test scaffolding
- **Documentation Requirement:** Maintainers must document coverage overrides in `CONTRIBUTING.md` with justification
- **Flexibility:** Coverage targets are guidelines, not absolute blockers. Lower coverage is acceptable with explanation and maintainer approval

## Documentation

- Keep [`README.md`](mdc:README.md) up to date with usage, features, and examples.
- Document all public functions and modules with doc comments.

## Miscellaneous

- Use `.gitignore` to exclude build artifacts and sensitive files.
- Use `.editorconfig` for consistent editor settings.
- Follow the guidelines in [`CONTRIBUTING.md`](mdc:CONTRIBUTING.md) for code contributions.
