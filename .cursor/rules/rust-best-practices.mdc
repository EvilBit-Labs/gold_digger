---
description:
globs:
alwaysApply: true
---

# Rust Best Practices for gold_digger

## Project Structure

- The main entry point is [`main.rs`](mdc:src/main.rs), which delegates core logic to library code in [`lib.rs`](mdc:src/lib.rs).
- Modules for output formats are organized as separate files: [`csv.rs`](mdc:src/csv.rs), [`json.rs`](mdc:src/json.rs), and [`tab.rs`](mdc:src/tab.rs).
- Shared logic and public APIs are exposed via [`lib.rs`](mdc:src/lib.rs).

## Module Organization

- Each output format (CSV, JSON, Tab) should have its own module with a `write` function that takes rows and an output writer.
- Follow the established pattern: `csv.rs`, `json.rs`, `tab.rs` with consistent `write<W: Write>(rows: impl IntoIterator<Item = impl IntoIterator<Item = impl AsRef<str>>>, output: &mut W) -> anyhow::Result<()>` interface.
- Import `std::io::Write` in all output format modules to enable generic writer support.
- Implementations should accept a mutable reference to any writer type (`&mut W where W: Write`) to support files, stdout, memory buffers, etc. without forcing moves.
- Use iterable parameters for rows to accept slices, iterators, or owned Vecs without unnecessary cloning.
- Callers should wrap file handles with `std::io::BufWriter` when passing to module write functions to reduce small-write overhead and improve performance.
- CLI module [`cli.rs`](mdc:src/cli.rs) contains Clap-based CLI definitions and configuration.
- Public functions in modules should be documented with doc comments (`///`).
- Use `pub mod` in [`lib.rs`](mdc:src/lib.rs) to expose modules.

## Format Module Contract

All format modules must implement:

```rust
pub fn write<W: Write>(
    rows: impl IntoIterator<Item = impl IntoIterator<Item = impl AsRef<str>>>,
    output: &mut W
) -> anyhow::Result<()>
```

This zero-copy API accepts:

- **Rows**: Any iterable of iterables (slices, Vecs, iterators) where items are convertible to `&str`
- **Output**: Mutable reference to any `Write` implementation (files, stdout, memory buffers)
- **Performance**: Avoids unnecessary allocations and supports streaming writes

## Code Quality Standards

### Formatting & Linting

- **Line limit**: 100 characters (enforced by `rustfmt.toml`)
- **Clippy warnings**: Zero tolerance (`-D warnings`)
- **Error handling**: Use `anyhow` for applications, `thiserror` for libraries
- **Documentation**: Doc comments (`///`) required for all public functions

### Essential Commands

```bash
just fmt-check    # cargo fmt --check (100-char line limit)
just lint         # cargo clippy -- -D warnings (ZERO tolerance)
just test         # cargo nextest run (preferred) or cargo test
just security     # cargo audit (advisory)
```

## Error Handling

- Use `anyhow::Result<T>` for applications
- Use `thiserror` for library error types
- Always use `?` for error propagation
- Add context with `.map_err()` for better debugging
- Avoid panics in production code; prefer returning errors
- Library crates must return Result-based errors instead of panicking

## Documentation Standards

Required for all public functions using `///`:

````rust
/// Converts MySQL rows to string vectors for output formatting.
///
/// # Arguments
/// * `rows` - Vector of MySQL rows from query execution
///
/// # Returns
/// * `Vec<Vec<String>>` - Converted string data ready for format modules
///
/// # Example
/// ```
/// let string_rows = rows_to_strings(mysql_rows)?;
/// let mut writer = std::io::BufWriter::new(std::fs::File::create("output.csv")?);
/// csv::write(&string_rows, &mut writer)?;
/// ```
pub fn rows_to_strings(rows: Vec<mysql::Row>) -> anyhow::Result<Vec<Vec<String>>> {
    // Implementation
}
````

## Code Style

- Follow [Rustfmt](mdc:https://github.com/rust-lang/rustfmt) conventions for formatting
- Use `snake_case` for function and variable names, `CamelCase` for types and structs
- Prefer iterators and combinators over manual loops where possible
- Use explicit types for function signatures, especially for public APIs
- Group imports by standard library, external crates, and local modules, separated by newlines

## Features and Conditional Compilation

- Use Cargo features (see `[features]` in [`Cargo.toml`](mdc:Cargo.toml)) to enable/disable output formats and verbose logging
- Use `#[cfg(feature = "...")]` to conditionally compile code based on enabled features

## Dependency Management

- Pin dependency versions in [`Cargo.toml`](mdc:Cargo.toml) and use minimal required features for each crate
- Use optional dependencies and features for extensibility (e.g., additional MySQL types, output formats)
- Use context7 website or MCP tool to get current documentation for APIs and crates

## Testing Guidelines

- Add tests in a `tests/` directory or as `#[cfg(test)]` modules within each file
- Validate all external input (e.g., environment variables) and handle missing/invalid values gracefully
- Prefer returning early on error conditions
- Target â‰¥80% coverage with `cargo llvm-cov`
