name: Release

on:
  push:
    tags:
      - "v[0-9]+.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release"
        required: true
        default: "v1.0.0"

permissions:
  contents: write
  id-token: write

jobs:
  resolve-tag:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
    outputs:
      tag: ${{ steps.get-tag.outputs.tag }}
    steps:
      - id: get-tag
        shell: bash
        env:
          REF: ${{ github.ref }}
          INPUT_TAG: ${{ github.event.inputs.tag }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          if [[ "${EVENT_NAME}" == "workflow_dispatch" && -n "${INPUT_TAG}" ]]; then
            if [[ ! "${INPUT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
              echo "Error: Provided tag '${INPUT_TAG}' does not match semantic versioning pattern." >&2
              exit 1
            fi
            echo "tag=${INPUT_TAG}" >> "$GITHUB_OUTPUT"
          elif [[ "${REF}" == refs/tags/* ]]; then
            TAG="${REF#refs/tags/}"
            if [[ ! "${TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
              echo "Error: Extracted tag '${TAG}' does not match semantic versioning pattern." >&2
              exit 1
            fi
            echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          else
            echo "Error: No valid tag detected. Please provide a valid semantic version tag." >&2
            exit 1
          fi

  create-release:
    needs: resolve-tag
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v5

      - name: Create GitHub Release
        uses: taiki-e/create-gh-release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

  build-and-package:
    needs: create-release
    strategy:
      matrix:
        os: [ubuntu-22.04, macos-13, windows-2022]
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write
    env:
      BIN_NAME: gold_digger
    steps:
      - uses: actions/checkout@v5

      - name: Install Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2

      - name: Install just
        uses: extractions/setup-just@v3

      - name: Build release
        shell: bash
        run: |
          echo "ðŸ”¨ Building release with rustls (pure Rust TLS)..."
          just build-rustls

      - name: Upload binaries to Release
        uses: taiki-e/upload-rust-binary-action@v1
        with:
          bin: ${{ env.BIN_NAME }}
          tar: unix
          zip: windows
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify built binaries
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            if [[ ! -f "target/release/${{ env.BIN_NAME }}.exe" ]]; then
              echo "Error: Windows binary not found at target/release/${{ env.BIN_NAME }}.exe" >&2
              exit 1
            fi
          else
            if [[ ! -f "target/release/${{ env.BIN_NAME }}" ]]; then
              echo "Error: Unix binary not found at target/release/${{ env.BIN_NAME }}" >&2
              exit 1
            fi
          fi
                    echo "âœ… Binary verification passed"

  sbom-and-sign:
    needs: [build-and-package, resolve-tag]
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v5

      - name: Install syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.9.2

      - name: Download release assets
        run: |
          mkdir -p dist
          gh release download "${{ needs.resolve-tag.outputs.tag }}" --dir dist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate SBOMs
        run: |
          mkdir -p sbom
          for f in dist/*; do
            if [ -f "$f" ] && [[ "$f" != *.sig ]] && [[ "$f" != *.crt ]]; then
              base=$(basename "$f")
              syft packages "file:$f" -o cyclonedx-json > "sbom/${base}.sbom.cdx.json"
            fi
          done

      - name: Upload SBOMs
        uses: softprops/action-gh-release@v2
        with:
          files: sbom/*.sbom.cdx.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Sign artifacts
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          for f in dist/*; do
            if [ -f "$f" ] && [[ "$f" != *.sig ]] && [[ "$f" != *.crt ]]; then
              cosign sign-blob --yes "$f" \
                --output-signature "${f}.sig" \
                --output-certificate "${f}.crt"
            fi
          done

      - name: Upload signatures
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist/*.sig
            dist/*.crt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
